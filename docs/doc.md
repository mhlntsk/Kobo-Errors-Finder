# Коротка структура

1. Сутності
   - Row - Втілює рядок однієї конкретної таблиці. Містить у собі поля, що відповідають колонкам таблиці.
     - `IMyRow` - загальний для рядків усіх таблиць інтерфейс.
     - `ConcreteRow1`
     - `ConcreteRow2`
     - ... 
   - Error - втілює помилки для одного конкретного рядка. Містить у собі bool-поля з усіма можливими типами помилок
     - `IError` - загальний для помилок усіх таблиць інтерфейс.
     - `ConcreteError1`
     - `ConcreteError2`
     - ...
2. Сервіси рівня додатку
   - `PathReaderService` - Запитує у користувача шлях до файлу. 
3. Три сервіси доменного рівня
   - `ConductorService` - Стратегія, для вибору алгоритму роботи з таблицею
   - `HeadersService` - Зчитує заголовки таблиці
   - `SheetsService` - Координує роботу інших сервісів sheet-by-sheet
4. Сервіси для специфічної обробки таблиць (свої для кожної окремої таблиці)
   - `Executor` - обирається за допомогою ConductorService, координує дію для окремого типу таблиці.
   - `Mapper` - Зчитує дані таблиці.
   - `Operator` - Перевіряє дані на наявність помилок.
   - `Printer` - Виводить результати роботи в консоль.


# Детальний опис
## Entities

Основний проект складається з двої видів сутностей, що успадковуються від інтерфейсів `IMyRow` та `IError`. 

> Примітка: ім'я `IMyRow` вибрано таким чином, щоби не конфліктувати з `IRow` з бібліотеки ***NPOI***.

Для кожної таблиці, що потребує специфічної перевірки, створена окрема конкретна реалізація інтерфейсу `IMyRow`, що відображає рядок з цієї таблиці і містить усі потрібні для перевірки поля. 

Щоб відображати помилки, які потенційно можна знайти в рядку, для кожної конкретної реалізації `IMyRow` створені відповідні конретні реалізації `IError`, які мають bool-поля з усіма можливими типами помилок.  

В папці "TablesExtensions" для кожного окремого типу таблиці існують 4 специфічних сервіси для диригування процесом (***Executors***), їх сканування (***Mappers***), виявлення помилок (***Operators***) та виведення останніх на екран (***Printers***).

Детальніше про ці специфічні сервіси трішки згодом.

## Точка входу та робота сервісів рівня додатку
Виконання програми починається з заповнення DI контейнера (UnityContainer) в методі `Main`. В даному конкретному випадку DI-container дає кілька суттєвих переваг:
1. Допомагає зменшити зв'язки між класами, особливо у випадку зі специфічними обробниками таблиць (Mappers, Operators and Printers), конкретні екземпляри яких залежать від вихідних даних "стратегії" *(див. нижче)*, в цьому випадку, жорстко закодовані залежності створили би багато додаткового коду. 
2. Підвищення читабельності та обслуговування коду.
3. DI-контейнери допомагають впровадити принцип інверсії управління, що сприяє зменшенню залежностей від конкретних реалізацій. З цього випливає також і наступний пункт.
4. Завдяки DI, код стає більш тестованим, а також легше ділити на модулі та розширювати.

Після цього створюється екземпляр класу `ConductorService`, що працює за принципом стратегії, і призначений для підмінювання логіки, це дозволяє динамічно додавати нові типи таблиць не змінюючи старого коду. Достатньо просто створити обробники (Executor, Mapper, Operator, Printer) для нової таблиці і зареєструвати її разом з Executor у точці входу програми за допомогою ConductorService.

:pushpin: **`ConductorService`** містить: 
 - Dictionary<string, IExecutor>, ключом у якому є назва таблиці, а значенням - відповідний цій таблиці Executor. 
 - Метод RegisterTable, який призначений для заповнення Dictionary. 
 - Абсолютно примітивний метод `GetExecutor(sheet.SheetName)` для отримання Executors за назвою таблиці.

Далі запускається простий цикл, який для компактності заключений у метод StartApplication класу Program. Він викликає єдиний метод класу `PathReaderService` - `GetPath();`, і якщо той повертає валідний шлях до файлу, викликається метод `CheckAllSheets(filePath);` класу `SheetsService`. 

:pushpin: **`SheetsService`**
`CheckAllSheets(string filePath)`, як видно, приймає лише шлях до файлу. В тілі створює `XSSFWorkbook` з бібліотеки ***NPOI*** і циклом для кожної сторінки документу робить наступне:
1. Отримує саму сторінку у вигляді об'єкта `ISheet`.
2. Отримує перший рядок на сторінці із заголовками.
3. Викликає `GetHeadersDictionary(firstRowWithHeaders);` Класу HeadersService. Метод просто конвертує заголовки з об'єкту IRow (бібліотеки ***NPOI***) в словник `Dictionary<string, int>`, де ключем є назва колонки а значенням - її прядковий номер.
4. За допомогою `ConductorService` отримує конкретну реалізацію інтерфейсу `IExecutor`. Саме на цьому рядку відбувається динамічна підстановка логіки патерном "Стратегія" у вигляді `ConcreteExecutor`, який є персональним для кожного виду таблиці.
5. Викликає на отриманому конкретному екземплярі Executor метод `Execute(sheet, headersOfSheet);`. 

## Робота доменних сервісів
:pushpin: **`Executor`**
За допомогою DI-container клас-виконувач отримує через конструктор інтерфейси решти специфічних сервісів - Mapper, Operator та Printer (Кожен executor свої). Окрім полів для сервісів Executor має також два поля з автовластивостями: `List<IMyRow>` та `List<IError>`, і метод `Execute(sheet, headersOfSheet);`. Так як Executor є простим диригентом, який контролює логіку обробки конкретної таблиці, він по черзі викликає методи кожного з севісів-обробників, деталі яких ми розберемо нижче:
```C#
mapedRowsFromTable = _mapper.Map(sheet, headersOfSheet);

errorsInRows = _operator.Check(mapedRowsFromTable);

_printer.Print(errorsInRows, mapedRowsFromTable);
```
:pushpin: **`Mapper`**
Усі конкретні мапери наслідуються від:
1. Інтерфейсу, закритого конкретним типом `IMapper<T> where T : class` - це дозволяє працювати з публічними контрактами а не з конкретною реалізацією, і одночасно допомагає DI-контейнеру розуміти, який тип потрібно надати тому чи іншому класу (чого не робить абстрактний клас (див. наступний пункт)). Публічний контракт інтерфейсу складається з одного методу:
   - `Map` - цей метод реалізований в **абстрактному класі** і має спільну логіку для усіх маперів. Для специфічної логіки він викликає **абстрактний метод** `MakeSpecificMapping`, який **визначений** в абстрактному класі а **реалізований** в конкретному.
2. Абстрактного класу `AbstractMapper`, який має спільну для всіх мапперів логіку в методі `Map` і має абстрактний метод `MakeSpecificMapping`.

Абстрактний метод `MakeSpecificMapping` має реалізацію в кожному конкретному класі. В ньому викликаються приватні методи мапінгу, які реалізовані окремо в кожному конкретному класі. Приклад:

```C#
public class BasicMapper : AbstractAgeValueMapper, IMapper<BasicMapper>
{
    public override IMyRow MakeSpecificMapping(Dictionary<string, int> headersOfSheet, IRow rowFromTable)
    {
        BasicRow myRow = new BasicRow();

        MapMsfPatientId(headersOfSheet, myRow, rowFromTable);

        // інші методи мапінгу, у т.ч. з абстрактного класу

        return myRow;
    }

    public void MapMsfPatientId(Dictionary<string, int> headersOfSheet, BasicRow myRow, IRow rowFromTable)
    {
        // конкретна реалізація
    }

    // реалізація інших методів мапінгу

}
```

:pushpin: **`Operator`**
Усі конкретні оператори наслідуються від `IOperator<T> where T : class`, і працюють схожим принципом з мапперами. Кожен оператор має власні приватні класи перевірки, які викликаються в методі `Check`, що реалізується від `IOperator`. Також інтерфейс має властивість `List<IError> errors`Приклад:
``` C#
public class BasicOperator : IOperator<BasicOperator>
{
    List<IError> errors = new List<IError>();
    public List<IError> Check(List<IMyRow> rows)
    {
        CheckSex(rows, errors);
        // виклик інших Check-методів

        return errors;
    }
    
    public void CheckSex(List<IMyRow> rows, List<IError> errors)
    {
        // Конкретна реалізація
    }

    // Інші Check-методи
}
```

:pushpin: **`Printer`**
Усі конкретні прінтери працюють за ідентичною схемою - `IPrinter<T> where T : class` та `AbstractPrinter` зі спільними методами `Print` та абстрактним `MakeSpecificPrinting`, що має реалізацію в конкретних прінтерах і всередині себе викликає приватні методи, що також реалізовані в конкретних прінтерах і для кожного прінтера особливі. 